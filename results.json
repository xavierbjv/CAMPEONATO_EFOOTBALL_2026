/* app.js — Campeonato eFootball 2026
   - Fuente de datos: results.json (misma carpeta)
   - Regla: si el partido es intra-participante (BJV/CLT/ROA) y score = "-", se define Empate automático (1-1)
*/

const DATA_URL = "results.json";

document.addEventListener("DOMContentLoaded", () => {
  init().catch(err => renderFatal(err));
});

async function init() {
  const data = await loadJson(DATA_URL);

  // Copia defensiva + normalización
  const normalized = normalizeData(data);

  // Regla de empates automáticos intra-participante
  const withAuto = applyAutoDraws(normalized);

  // Calcular tabla desde matchdays
  const standings = computeStandings(withAuto);

  // Render
  renderLastUpdated(withAuto.lastUpdated);
  renderStandings(standings);
  renderMatchdays(withAuto);
}

/* =========================
   Carga/normalización
========================= */

async function loadJson(url) {
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) {
    throw new Error(`No se pudo cargar ${url}. HTTP ${res.status}`);
  }
  return await res.json();
}

function normalizeData(data) {
  const safe = structuredClone(data ?? {});
  safe.lastUpdated = String(safe.lastUpdated ?? "").trim();

  if (!Array.isArray(safe.matchdays)) safe.matchdays = [];
  safe.matchdays = safe.matchdays.map(md => ({
    name: String(md?.name ?? "Jornada").trim(),
    matches: Array.isArray(md?.matches) ? md.matches.map(m => ({
      home: String(m?.home ?? "").trim(),
      away: String(m?.away ?? "").trim(),
      score: String(m?.score ?? "-").trim()
    })) : []
  }));

  // standings en el JSON puede venir como base, pero aquí se recalcula igual.
  if (!Array.isArray(safe.standings)) safe.standings = [];

  return safe;
}

/* =========================
   Regla: Empate automático
========================= */

function applyAutoDraws(data) {
  const out = structuredClone(data);

  for (const md of out.matchdays) {
    for (const m of md.matches) {
      const pHome = participantOf(m.home);
      const pAway = participantOf(m.away);

      // Solo si ambos son del mismo participante (BJV/CLT/ROA)
      const intra = pHome && pAway && pHome === pAway;

      if (intra) {
        const s = (m.score || "-").trim();
        if (s === "-" || s === "") {
          m.score = "Empate automático (1-1)";
        }
      }
    }
  }
  return out;
}

function participantOf(teamName) {
  // Formato esperado: "BJV - FRANCIA"
  // Retorna "BJV", "CLT", "ROA" si aplica
  const t = String(teamName ?? "");
  const parts = t.split(" - ");
  if (parts.length < 2) return "";
  const p = parts[0].trim().toUpperCase();
  return ["BJV", "CLT", "ROA"].includes(p) ? p : "";
}

/* =========================
   Parseo de marcadores
========================= */

function parseScore(scoreStr) {
  const s = String(scoreStr ?? "").trim();

  if (!s || s === "-") return null;

  // Caso: "Empate automático (1-1)" u otros textos con (x-y)
  const paren = s.match(/\((\d+)\s*[-:–]\s*(\d+)\)/);
  if (paren) return { gf: Number(paren[1]), gc: Number(paren[2]), label: s };

  // Caso: "2-1" / "2:1" / "2–1"
  const plain = s.match(/^(\d+)\s*[-:–]\s*(\d+)$/);
  if (plain) return { gf: Number(plain[1]), gc: Number(plain[2]), label: s };

  return null; // Formato desconocido → no computa
}

/* =========================
   Cálculo de posiciones
========================= */

function computeStandings(data) {
  // Obtiene lista de equipos desde standings base y/o partidos
  const teams = new Set();

  for (const s of (data.standings || [])) {
    if (s?.name) teams.add(String(s.name).trim());
  }
  for (const md of data.matchdays) {
    for (const m of md.matches) {
      if (m.home) teams.add(m.home);
      if (m.away) teams.add(m.away);
    }
  }

  // Inicializar tabla
  const table = {};
  for (const name of teams) {
    table[name] = {
      name,
      pj: 0, pg: 0, pe: 0, pp: 0,
      gf: 0, gc: 0, dg: 0, pts: 0
    };
  }

  // Recorrer partidos jugados (incluye empates automáticos)
  for (const md of data.matchdays) {
    for (const m of md.matches) {
      const home = m.home;
      const away = m.away;

      if (!table[home] || !table[away]) continue;

      const parsed = parseScore(m.score);
      if (!parsed) continue; // no jugado o formato inválido

      const hg = parsed.gf;
      const ag = parsed.gc;

      // PJ / GF / GC
      table[home].pj += 1;
      table[away].pj += 1;

      table[home].gf += hg;
      table[home].gc += ag;

      table[away].gf += ag;
      table[away].gc += hg;

      // Resultado
      if (hg > ag) {
        table[home].pg += 1;
        table[away].pp += 1;
        table[home].pts += 3;
      } else if (hg < ag) {
        table[away].pg += 1;
        table[home].pp += 1;
        table[away].pts += 3;
      } else {
        table[home].pe += 1;
        table[away].pe += 1;
        table[home].pts += 1;
        table[away].pts += 1;
      }
    }
  }

  // Calcular DG
  const arr = Object.values(table).map(x => ({
    ...x,
    dg: x.gf - x.gc
  }));

  // Orden: PTS, DG, GF, nombre
  arr.sort((a, b) => (
    b.pts - a.pts ||
    b.dg - a.dg ||
    b.gf - a.gf ||
    a.name.localeCompare(b.name, "es")
  ));

  // Posición
  arr.forEach((x, i) => x.pos = i + 1);

  return arr;
}

/* =========================
   Render UI
========================= */

function renderLastUpdated(lastUpdated) {
  const el = document.getElementById("lastUpdated");
  if (!el) return;

  const text = lastUpdated ? `Actualizado: ${lastUpdated}` : "Actualización: N/D";
  el.textContent = text;
}

function renderStandings(rows) {
  const root = document.getElementById("standings");
  if (!root) return;

  const html = `
    <table aria-label="Tabla de posiciones">
      <thead>
        <tr>
          <th>Pos</th>
          <th>Equipo</th>
          <th>PJ</th>
          <th>PG</th>
          <th>PE</th>
          <th>PP</th>
          <th>GF</th>
          <th>GC</th>
          <th>DG</th>
          <th>PTS</th>
        </tr>
      </thead>
      <tbody>
        ${rows.map(r => `
          <tr>
            <td>${r.pos}</td>
            <td>${escapeHtml(r.name)}</td>
            <td>${r.pj}</td>
            <td>${r.pg}</td>
            <td>${r.pe}</td>
            <td>${r.pp}</td>
            <td>${r.gf}</td>
            <td>${r.gc}</td>
            <td>${r.dg}</td>
            <td>${r.pts}</td>
          </tr>
        `).join("")}
      </tbody>
    </table>
  `;

  root.innerHTML = html;
}

function renderMatchdays(data) {
  const root = document.getElementById("matchdays");
  if (!root) return;

  const html = `
    <div class="grid">
      ${(data.matchdays || []).map(md => {
        const played = (md.matches || []).filter(m => !!parseScore(m.score)).length;
        const total = (md.matches || []).length;

        return `
          <details class="matchday" open>
            <summary class="row" role="listitem" aria-label="${escapeHtml(md.name)}">
              <span>${escapeHtml(md.name)}</span>
              <span class="badge">${played}/${total}</span>
            </summary>

            <div style="margin-top:10px;">
              ${(md.matches || []).map(m => renderMatch(m)).join("")}
            </div>
          </details>
        `;
      }).join("")}
    </div>
  `;

  root.innerHTML = html;
}

function renderMatch(m) {
  const parsed = parseScore(m.score);
  const isAuto = String(m.score || "").toLowerCase().includes("empate automático");

  const scoreLabel = parsed ? parsed.label : "-";
  const badge = isAuto ? `<span class="badge">AUTO</span>` : "";

  return `
    <div class="row" style="padding:10px 0; border-bottom:1px solid rgba(31,42,58,.6);">
      <div style="min-width:0;">
        <div style="font-size:14px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
          ${escapeHtml(m.home)} vs ${escapeHtml(m.away)}
        </div>
        <div class="muted" style="font-size:12px; margin-top:2px;">
          ${escapeHtml(scoreLabel)}
        </div>
      </div>
      <div style="display:flex; gap:8px; align-items:center;">
        ${badge}
      </div>
    </div>
  `;
}

function renderFatal(err) {
  const main = document.getElementById("main");
  if (!main) return;

  main.innerHTML = `
    <section class="card">
      <h2>Error de carga</h2>
      <p class="muted">No se pudo generar la tabla de posiciones ni los resultados.</p>
      <pre style="white-space:pre-wrap; overflow:auto; border:1px solid rgba(31,42,58,.8); padding:12px; border-radius:10px;">
${escapeHtml(String(err?.message || err))}
      </pre>
      <p class="muted">Verifique que results.json exista en la raíz del repositorio y que el sitio se ejecute por HTTP (GitHub Pages / http.server).</p>
    </section>
  `;
}

function escapeHtml(str) {
  return String(str ?? "")
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}
